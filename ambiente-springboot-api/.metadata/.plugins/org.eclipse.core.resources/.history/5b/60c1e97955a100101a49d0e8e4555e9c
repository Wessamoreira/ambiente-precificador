package com.precificapro.service;

import com.precificapro.controller.dto.SimulationRequestDTO;
import com.precificapro.controller.dto.SimulationResponseDTO;
import com.precificapro.domain.enums.PricingMethod;
import com.precificapro.domain.enums.RoundingRule;
import com.precificapro.domain.model.CostItem;
import com.precificapro.domain.model.PricingProfile;
import com.precificapro.domain.model.Product;
import com.precificapro.domain.model.User;
import com.precificapro.domain.repository.CostItemRepository;
import com.precificapro.domain.repository.FreightBatchRepository;
import com.precificapro.domain.repository.PricingProfileRepository;
import com.precificapro.domain.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;

@Service
public class PricingSimulationService {

    @Autowired private ProductRepository productRepository;
    @Autowired private PricingProfileRepository profileRepository;
    @Autowired private CostItemRepository costItemRepository;
    @Autowired private FreightBatchRepository freightBatchRepository;

    private static final MathContext MC = new MathContext(10, RoundingMode.HALF_UP);

    @Transactional(readOnly = true)
    public SimulationResponseDTO simulate(SimulationRequestDTO request, User owner) {

        // 1. CARREGAR DADOS COM SEGURANÇA
        Product product = productRepository.findByIdAndOwner(request.productId(), owner)
                .orElseThrow(() -> new RuntimeException("Produto não encontrado."));
        PricingProfile profile = profileRepository.findByIdAndOwner(request.profileId(), owner)
                .orElseThrow(() -> new RuntimeException("Perfil de precificação não encontrado."));

        // 2. APLICAR OVERRIDES (se existirem)
        SimulationRequestDTO.OverrideDTO override = request.override();
        BigDecimal purchaseCost = (override != null && override.purchaseCost() != null) ? override.purchaseCost() : product.getDefaultPurchaseCost();
        BigDecimal packagingCost = (override != null && override.packagingCost() != null) ? override.packagingCost() : product.getDefaultPackagingCost();
        BigDecimal otherVariableCost = (override != null && override.otherVariableCost() != null) ? override.otherVariableCost() : product.getDefaultOtherVariableCost();
        int salesTarget = (override != null && override.monthlySalesTarget() != null) ? override.monthlySalesTarget() : profile.getMonthlySalesTarget();
        BigDecimal machineFeePct = (override != null && override.machineFeePct() != null) ? override.machineFeePct() : profile.getMachineFeePct();
        BigDecimal marketplaceFeePct = (override != null && override.marketplaceFeePct() != null) ? override.marketplaceFeePct() : profile.getMarketplaceFeePct();
        BigDecimal otherFeesPct = (override != null && override.otherFeesPct() != null) ? override.otherFeesPct() : profile.getOtherFeesPct();

        // 3. CALCULAR CUSTO DIRETO UNITÁRIO
        BigDecimal freightCostUnit = freightBatchRepository.findFirstByProductOrderByCreatedAtDesc(product)
                .map(batch -> batch.getFreightTotal().divide(BigDecimal.valueOf(batch.getBatchSize()), MC))
                .orElse(BigDecimal.ZERO);

        BigDecimal directCostUnit = purchaseCost.add(packagingCost).add(otherVariableCost).add(freightCostUnit);

        // 4. CALCULAR CUSTO INDIRETO UNITÁRIO (RATEIO)
        BigDecimal totalFixedCosts = costItemRepository.findByOwnerAndActiveTrue(owner).stream()
                .map(CostItem::getAmountMonthly)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal indirectCostUnit = totalFixedCosts.divide(BigDecimal.valueOf(salesTarget), MC);

        // 5. CALCULAR CUSTO TOTAL
        BigDecimal totalCostUnit = directCostUnit.add(indirectCostUnit);

        // 6. CALCULAR PREÇO DE VENDA (ANTES DO ARREDONDAMENTO)
        BigDecimal totalFeesPct = machineFeePct.add(marketplaceFeePct).add(otherFeesPct);
        BigDecimal price;
        if (profile.getMethod() == PricingMethod.MARKUP) {
            price = totalCostUnit.multiply(BigDecimal.ONE.add(profile.getMarkup())).divide(BigDecimal.ONE.subtract(totalFeesPct), MC);
        } else { // MARGIN
            price = totalCostUnit.divide(BigDecimal.ONE.subtract(totalFeesPct).subtract(profile.getMarginOnPrice()), MC);
        }

        // 7. APLICAR ARREDONDAMENTO
        BigDecimal suggestedPrice = applyRounding(price, profile.getRoundingRule());

        // 8. CALCULAR MÉTRICAS FINAIS
        BigDecimal contributionMarginUnit = suggestedPrice.multiply(BigDecimal.ONE.subtract(totalFeesPct)).subtract(directCostUnit);
        Integer breakEvenUnits = (contributionMarginUnit.compareTo(BigDecimal.ZERO) > 0)
                ? totalFixedCosts.divide(contributionMarginUnit, 0, RoundingMode.CEILING).intValue()
                : null; // Ponto de equilíbrio infinito se a margem for zero ou negativa

        // 9. MONTAR PROJEÇÃO MENSAL
        BigDecimal revenue = suggestedPrice.multiply(BigDecimal.valueOf(salesTarget));
        BigDecimal totalDirectCost = directCostUnit.multiply(BigDecimal.valueOf(salesTarget));
        BigDecimal netProfit = revenue.multiply(BigDecimal.ONE.subtract(totalFeesPct)).subtract(totalDirectCost).subtract(totalFixedCosts);

        SimulationResponseDTO.MonthlyProjectionDTO monthlyProjection = new SimulationResponseDTO.MonthlyProjectionDTO(
                revenue.setScale(2, RoundingMode.HALF_UP),
                totalDirectCost.setScale(2, RoundingMode.HALF_UP),
                totalFixedCosts.setScale(2, RoundingMode.HALF_UP),
                netProfit.setScale(2, RoundingMode.HALF_UP)
        );
        
        // 10. MONTAR E RETORNAR A RESPOSTA
        return new SimulationResponseDTO(
                suggestedPrice,
                directCostUnit.setScale(2, RoundingMode.HALF_UP),
                indirectCostUnit.setScale(2, RoundingMode.HALF_UP),
                totalCostUnit.setScale(2, RoundingMode.HALF_UP),
                contributionMarginUnit.setScale(2, RoundingMode.HALF_UP),
                breakEvenUnits,
                monthlyProjection
        );
    }
    
    private BigDecimal applyRounding(BigDecimal price, RoundingRule rule) {
        if (rule == null || rule == RoundingRule.NONE) {
            return price.setScale(2, RoundingMode.HALF_UP);
        }

        long integerPart = price.longValue();
        BigDecimal decimalPart = price.subtract(BigDecimal.valueOf(integerPart));

        return switch (rule) {
            case UP_TO_0_90 -> {
                if (decimalPart.compareTo(BigDecimal.valueOf(0.90)) <= 0) {
                    yield BigDecimal.valueOf(integerPart).add(BigDecimal.valueOf(0.90));
                } else {
                    yield BigDecimal.valueOf(integerPart + 1).add(BigDecimal.valueOf(0.90));
                }
            }
            case UP_TO_0_99 -> {
                // Lógica similar...
                yield BigDecimal.valueOf(integerPart).add(BigDecimal.valueOf(0.99));
            }
            case UP_TO_0_50 -> {
                // Lógica similar...
                yield BigDecimal.valueOf(integerPart).add(BigDecimal.valueOf(0.50));
            }
            default -> price.setScale(2, RoundingMode.HALF_UP);
        };
    }
}